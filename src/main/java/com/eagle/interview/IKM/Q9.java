package com.eagle.interview.IKM;

/**
 * 按位非（NOT）按位非也叫做补，一元运算符NOT“~”是对其运算数的每一位取反
 *
 * 在java中int数据类型一般是四个字节，一个字节8位，一个完整的int类型是32位。
 *
 * 在计算机内是以二进制进行存储的，计算机在存储某个数据时，是存储的数据的补码。
 *
 * 补码与原码关系：正数补码与原码相同，负数补码是原码减1后取反。
 *
 * 例如：5
 *
 * 原码是：00000000 00000000 00000000 00000101
 *
 * 补码是：00000000 00000000 00000000 00000101（计算机内存储）
 *
 * 例如：-5
 *
 * 原码：10000000 00000000 00000000 00000101
 *
 * 补码：11111111 11111111 11111111 11111011（计算机内存储）
 *
 * 了解了原码补码我们来看位非~运算符
 *
 * 例如：~5
 *
 * 5的原码取反：11111111 11111111 11111111 11111010（这就是~5在计算机存储的补码）
 *
 * 需要将补码计算出原码然后转化为十进制，高位不变，取反+1
 *
 * 高位不变,取反
 *       10000000 00000000 00000000 00000101
 * +1，结果：
 *       10000000 00000000 00000000 00000110
 *
 * 十进制：-6
 */
public class Q9 {
	public static void main(String[] args) {
		int x = 8;
		/**
		 * 8的原码是（int数据类型一般是四个字节，一个字节8位，一个完整的int类型是32位）
		 * 00000000 000000000 0000000000 00001000
		 *
		 * 非~运算符后取反，变成
		 * 11111111 11111111 11111111 11110111
		 *
		 * 这个是补码，而且是个负数，根据原码>补码的计算过程。负数补码是原码减1后取反
		 * 这里是逆向，应该是先取反
		 * 00000000 00000000 00000000 00001000
		 *
		 * 高位是符号位不能改变，所以
		 * 10000000 00000000 00000000 00001000
		 *
		 * 然后+1，得到原码
		 * 10000000 00000000 00000000 00001001
		 *
		 * 转成二进制
		 * -9
		 *
		 */
		System.out.println(~x);
	}
}
